# PipeOverIP
ps. I know the name is bad. It is a temporary name.

## About
This was a morning idea of mine which was something along the lines of "Can we | (pipe) things over the internet?", and a small thinking session about how we are able to receive stdin and give stdout in Rust, and when paired with a low-level network interface it could be done.  
Halfway through the project I remembered nc existed.

At the time of writing (12/02/2023 in dd/mm/yy format) I am new to Rust, and I do not claim the code is optimal. There are probably lots of improvements to be made.

## Installation & Running
After running `cargo build`, preferably with the `--release` flag, the binary can be run directly with specifying at least the mode (`-m` flag). If you run the binary executable with the `--help` flag, it will display a nice dialogue generated by Clap (the command line argument parser this project uses) and show you all the flags.  
The flags are listed below, directly copied from the dialogue itself.

```
Options:
  -m, --mode <MODE>
  -a, --address <ADDRESS>  [default: 0.0.0.0:53092]
  -b, --bufsize <BUFSIZE>  [default: 8193]
  -k, --keep-open
  -s, --silent
```

The `-m` or `--mode` flag should either receive r/receive or s/send as its value, or the program will output an invalid value message and exit.  
The address is optional, it defaults to `0.0.0.0:53092`, and it is intended for the sender.  
The buffer size is optional and it is 8193 (8192 + 1 for the terminator) by default.  
The keep open flag is implemented for the project to be a bit more similar to nc, by default the receiver exits when it receives data and finishes reading it to pipe it to another program. With the -k flag specified it does not terminate until an interruption signal is sent with Ctrl+C.  
The silent flag specifies whether the functions should be silent.

Example usage:  
- Receiver: `pipeoverip -m r | wc`  
- Receiver with keep open: `pipeoverip -m r -k | lolcat`  
- Sender: `echo "hi someotherip" | pipeoverip -m s -a "192.168.1.150:53092"`   
- Silent Sender: `find . -name "*.iso" -type f | pipeoverip -m s -a "192.168.1.150:53092"`   

## Known Bugs & Issues
None as far as I know. 

## What to Do
Although it would be nice to warn the sender if the receiver buffer isn't big enough to read all the data, at the moment I can't think of a good way to do this, probably caused by me being inexperienced. Maybe implementing "packets" could be a good idea?  
With the next update I plan to implement password-based encryption to differentiate it from nc, and it would be a nice exercise to practice using encryption libraries in Rust and in general.  
Implementing a special character sequence acting as an escape sequence to terminate a receiver in keep-open mode?